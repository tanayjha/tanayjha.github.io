<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Euclids GCD Algorithm | </title><meta name=keywords content><meta name=description content="This post is going to focus on a very simple concept, finding the GCD of two numbers. If you think this is too easy and we don&rsquo;t need a post on it, well you are probably right :D. You might even be knowing of efficient ways of finding the GCD (mostly used in competitive programming). But many of you may not be aware of the mathematics and proof behind how that method works."><meta name=author content><link rel=canonical href=https://tanayjha.github.io/blog/euclid-gcd-algo/><link crossorigin=anonymous href=/assets/css/stylesheet.d7fb4cbf980fe688a21621b06a795933c4e6bb2d4070ec940667af1715d84af2.css integrity="sha256-1/tMv5gP5oiiFiGwanlZM8Tmuy1AcOyUBmevFxXYSvI=" rel="preload stylesheet" as=style><script defer crossorigin=anonymous src=/assets/js/highlight.f413e19d0714851f6474e7ee9632408e58ac146fbdbe62747134bea2fa3415e0.js integrity="sha256-9BPhnQcUhR9kdOfuljJAjlisFG+9vmJ0cTS+ovo0FeA=" onload=hljs.initHighlightingOnLoad()></script><link rel=icon href=https://tanayjha.github.io/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://tanayjha.github.io/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://tanayjha.github.io/favicon-32x32.png><link rel=apple-touch-icon href=https://tanayjha.github.io/apple-touch-icon.png><link rel=mask-icon href=https://tanayjha.github.io/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=en href=https://tanayjha.github.io/blog/euclid-gcd-algo/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--hljs-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><meta property="og:title" content="Euclids GCD Algorithm"><meta property="og:description" content="This post is going to focus on a very simple concept, finding the GCD of two numbers. If you think this is too easy and we don&rsquo;t need a post on it, well you are probably right :D. You might even be knowing of efficient ways of finding the GCD (mostly used in competitive programming). But many of you may not be aware of the mathematics and proof behind how that method works."><meta property="og:type" content="article"><meta property="og:url" content="https://tanayjha.github.io/blog/euclid-gcd-algo/"><meta property="article:section" content="blog"><meta property="article:published_time" content="2021-03-08T12:09:25+05:30"><meta property="article:modified_time" content="2021-03-08T12:09:25+05:30"><meta name=twitter:card content="summary"><meta name=twitter:title content="Euclids GCD Algorithm"><meta name=twitter:description content="This post is going to focus on a very simple concept, finding the GCD of two numbers. If you think this is too easy and we don&rsquo;t need a post on it, well you are probably right :D. You might even be knowing of efficient ways of finding the GCD (mostly used in competitive programming). But many of you may not be aware of the mathematics and proof behind how that method works."><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Blogs","item":"https://tanayjha.github.io/blog/"},{"@type":"ListItem","position":2,"name":"Euclids GCD Algorithm","item":"https://tanayjha.github.io/blog/euclid-gcd-algo/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Euclids GCD Algorithm","name":"Euclids GCD Algorithm","description":"This post is going to focus on a very simple concept, finding the GCD of two numbers. If you think this is too easy and we don\u0026rsquo;t need a post on it, well you are probably right :D. You might even be knowing of efficient ways of finding the GCD (mostly used in competitive programming). But many of you may not be aware of the mathematics and proof behind how that method works.","keywords":[],"articleBody":"This post is going to focus on a very simple concept, finding the GCD of two numbers. If you think this is too easy and we don’t need a post on it, well you are probably right :D. You might even be knowing of efficient ways of finding the GCD (mostly used in competitive programming). But many of you may not be aware of the mathematics and proof behind how that method works. If that is the case, you are not alone. I was in the same boat for many years. I have used that 3 line GCD method many times in solving programming questions never thinking deeply about why it works. There is no issue in this. After all there is a good reason why abstraction is so popular. But I do believe that when you get a chance there is no harm in diving deep. You may get to learn a few things and as always be fascinated by what math has to offer even in the simplest of concepts. So lets begin…\nContext Now we all know one way at least of finding the GCD of two numbers. Find all the factors of both the numbers and find the one which is common between the two and which is the largest. Well agreed this is just a repeat of the definition of GCD but if you do exactly this you will find the GCD which makes sense. The problem is that this method is not very efficient. It’s probably fine to do this when the numbers you are calculating GCD for are small but things start to get ugly as the numbers become big. So we need a more systematic and efficient method of calculating the GCD which is exactly the purpose of this blog. But before we understand that method lets start with some basic definition and we will build up our theory from there.\nThe Division Algorithm When solving things from first principles, we have to get down at the basic level. Once you go down there, you realize how many things we take for granted without having the proper proof. Again, I am not advocating that you should prove everything you use, but at least trying that can be a fun and educational activity. So I am going to do that. I feel it gives more confidence in the final result.\nSo lets start with the statement of the division algorithm.\nGiven integers a and b with b \u003e 0, there exists unique integers q and r satisfying, a = bq + r, 0 \u003c= r \u003c b.\nProof: First we need to prove the existence of numbers q and r. Then we will focus on uniqueness.\nLets begin by proving that the set S = { a - xb | x is an integer, a - xb \u003e= 0 } is non empty. So we need to find an integer x such that a - xb \u003e= 0. We know that b \u003e= 1 and a is an integer. Lets take x = -|a|. Substituting that in we get, a - (-|a|.b) = a + |a|b \u003e= a + |a| (as b \u003e= 1) \u003e= 0. Hence this lies in S and S is non empty. By the Well Ordering Principle, the set contains a least element, lets call it r. So there exists some integer q for which r = a - qb where r \u003e= 0.\nWe argue that r \u003c b. We can prove this by contradiction. Assume r \u003e= b. Consider the number, a - (q + 1)b = (a - qb) - b = r - b \u003e= 0 also r - b \u003c r contradicting r as the smallest element in the set S. Hence r \u003c b. This proves existence of q and r in the division algorithm. Lets now prove the uniqueness.\nAgain we start with a contradiction that there are two values, q1, q2 and r1, r2 satisfying this equation. So a = bq1 + r1 and a = bq2 + r2 where 0 \u003c= r1 \u003c b and 0 \u003c= r2 \u003c b. =\u003e bq1 + r1 = bq2 + r2 =\u003e r1 - r2 = b(q2- q1). Now since r1 and r2 are both \u003c b =\u003e -b \u003c r1 - r2 \u003c b =\u003e 0 \u003c= (q2 - q1) \u003c 1 and since q2 - q1 is an integer it must be 0. =\u003e q1 = q2 and r1 = r2 thereby completing the proof.\nThe Eucledian Algorithm Now, lets start interacting with the gcd and take the first step towards euclids algorithm. We first introduce a lemma which will more or less pave the way to the actual algorithm.\nLemma: If a = bq + r then gcd(a, b) = gcd(b, r).\nProof: This statement did not look obvious to me at least in anyway. So the only way to convince ourselves that this is true is by proving it.\nLets say gcd(a, b) = d =\u003e d | a and d | b also for all e such that e | a and e | b, e | d. (note that this is actually the definition of GCD expressed in mathematical terms)\nNow if d | a and d | b =\u003e d | a - bq =\u003e d | r. So d is definitely a candidate to be the gcd(b, r) since it divides both b and r. But we don’t know if it is the highest such divisor. Lets assume its not and assume that there is an integer e which is the gcd(b, r) =\u003e e | b and e | r. So e | bq + r =\u003e e | a. Now gcd(a, b) = d. And since e | a and e | b, e \u003c= d. Since if e \u003e d, then e should have been the gcd of a and b. This proves that d is also the gcd(b, r) thereby proving the lemma.\nNow that we have proved this seemingly unintuitive result, here comes the masterstroke step of euclids algorithm. We apply the division algorithm repeatedly, giving us the following set of equations:\na = bq + r, 0 \u003c r \u003c b b = rq1 + r1, 0 \u003c r1 \u003c r r = r1q2 + r2, 0 \u003c r2 \u003c r1 r1 = r2q3 + r3, 0 \u003c r3 \u003c r2 . . . rn-1= rnqn+1 + rn+1, where rn+1 = 0.\nBasically we claim that since the remainders, r1, r2 etc. are strictly decreasing, it will become 0 after n number of steps. (max b steps to be precise).\nNow if we apply the above gcd lemma to these equations sequentially we will get the following:\ngcd(a, b) = gcd(b, r) = gcd(r, r1) … = gcd(rn-1, rn) = gcd(rn, 0) = rn\nThe above statement basically gives us a new method of finding the gcd of two numbers. Simply put, it says to apply the division algorithm repeatedly to the numbers and once the remainder becomes 0 (which it eventually will), the quotient at that stage is the gcd.\nHere is the 3 line method of GCD calculation now.\nIf you understand recursion well. shouldn’t be hard to see how this is exactly the code conversion of the process illustrated above and why this should give the GCD.\nComplexity analysis The time complexity of this method is log(max(a, b)). So basically logarithmic. I tried reading the proof of this but it is a bit complicated. Turns out the worst case happens with consecutive fibonaaci numbers and is related to the golden ration. Definitely seems like a good thing to explore. However not going to do that in this post. Anyway, I will have to read about it first myself to get a proper understanding. Maybe in a future post..\nUpdate: Read around a bit and found a few sources. This is the concrete analysis of the runtime as given by Knuth in his TOACP book. I found it to be very involved and difficult to understand. Feel free to give it a shot if you want. This on the other hand is a little less rigorous but still a good proof of the logarithmic runtime. It uses very simple arguments and shouldn’t be hard to understand. Feel free to go through it.\nHopefully this post gives you more confidence in using the Euclidean method of finding the GCD from now on. And even if you never use it, who cares. What would matter is how the proof made you feel and not if it was useful :)\n","wordCount":"1440","inLanguage":"en","datePublished":"2021-03-08T12:09:25+05:30","dateModified":"2021-03-08T12:09:25+05:30","mainEntityOfPage":{"@type":"WebPage","@id":"https://tanayjha.github.io/blog/euclid-gcd-algo/"},"publisher":{"@type":"Organization","name":"","logo":{"@type":"ImageObject","url":"https://tanayjha.github.io/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button><ul class=lang-switch><li>|</li></ul></div></div><ul id=menu></ul></nav></header><main class=main><article class=post-single><header class=post-header><h1 class=post-title>Euclids GCD Algorithm</h1><div class=post-meta>&lt;span title='2021-03-08 12:09:25 +0530 +0530'>March 8, 2021&lt;/span>&amp;nbsp;·&amp;nbsp;7 min</div></header><div class=toc><details><summary accesskey=c title="(Alt + C)"><span class=details>Table of Contents</span></summary><div class=inner><ul><li><a href=#context aria-label=Context>Context</a></li><li><a href=#the-division-algorithm aria-label="The Division Algorithm">The Division Algorithm</a></li><li><a href=#the-eucledian-algorithm aria-label="The Eucledian Algorithm">The Eucledian Algorithm</a></li><li><a href=#complexity-analysis aria-label="Complexity analysis">Complexity analysis</a></li></ul></div></details></div><div class=post-content><p>This post is going to focus on a very simple concept, finding the <a href="https://en.wikipedia.org/wiki/Greatest_common_divisor#:~:text=In%20mathematics%2C%20the%20greatest%20common,divides%20each%20of%20the%20integers">GCD</a> of two numbers. If you think this is too easy and we don&rsquo;t need a post on it, well you are probably right :D. You might even be knowing of efficient ways of finding the GCD (mostly used in competitive programming). But many of you may not be aware of the mathematics and proof behind how that method works. If that is the case, you are not alone. I was in the same boat for many years. I have used that <a href=https://en.wikipedia.org/wiki/Euclidean_algorithm#Implementations>3 line GCD</a> method many times in solving programming questions never thinking deeply about why it works. There is no issue in this. After all there is a good reason why abstraction is so popular. But I do believe that when you get a chance there is no harm in diving deep. You may get to learn a few things and as always be fascinated by what math has to offer even in the simplest of concepts. So lets begin&mldr;</p><h3 id=context>Context<a hidden class=anchor aria-hidden=true href=#context>#</a></h3><p>Now we all know one way at least of finding the GCD of two numbers. Find all the factors of both the numbers and find the one which is common between the two and which is the largest. Well agreed this is just a repeat of the definition of GCD but if you do exactly this you will find the GCD which makes sense. The problem is that this method is not very efficient. It&rsquo;s probably fine to do this when the numbers you are calculating GCD for are small but things start to get ugly as the numbers become big.
So we need a more systematic and efficient method of calculating the GCD which is exactly the purpose of this blog.
But before we understand that method lets start with some basic definition and we will build up our theory from there.</p><h3 id=the-division-algorithm>The Division Algorithm<a hidden class=anchor aria-hidden=true href=#the-division-algorithm>#</a></h3><p>When solving things from first principles, we have to get down at the basic level. Once you go down there, you realize how many things we take for granted without having the proper proof. Again, I am not advocating that you should prove everything you use, but at least trying that can be a fun and educational activity. So I am going to do that. I feel it gives more confidence in the final result.</p><p>So lets start with the statement of the division algorithm.</p><p>Given integers a and b with b > 0, there exists unique integers q and r satisfying, a = bq + r, 0 &lt;= r &lt; b.</p><p><strong>Proof</strong>: First we need to prove the existence of numbers q and r. Then we will focus on uniqueness.</p><p>Lets begin by proving that the set S = { a - xb | x is an integer, a - xb >= 0 } is non empty.
So we need to find an integer x such that a - xb >= 0. We know that b >= 1 and a is an integer.
Lets take x = -|a|. Substituting that in we get, a - (-|a|.b) = a + |a|b >= a + |a| (as b >= 1) >= 0. Hence this lies in S and S is non empty. By the <a href=https://en.wikipedia.org/wiki/Well-ordering_principle>Well Ordering Principle</a>, the set contains a least element, lets call it r. So there exists some integer q for which r = a - qb where r >= 0.</p><p>We argue that r &lt; b. We can prove this by contradiction. Assume r >= b. Consider the number,
a - (q + 1)b = (a - qb) - b = r - b >= 0 also r - b &lt; r contradicting r as the smallest element in the set S. Hence r &lt; b. This proves existence of q and r in the division algorithm. Lets now prove the uniqueness.</p><p>Again we start with a contradiction that there are two values, q1, q2 and r1, r2 satisfying this equation.
So a = bq1 + r1 and a = bq2 + r2 where 0 &lt;= r1 &lt; b and 0 &lt;= r2 &lt; b.
=> bq1 + r1 = bq2 + r2 => r1 - r2 = b(q2- q1).
Now since r1 and r2 are both &lt; b => -b &lt; r1 - r2 &lt; b => 0 &lt;= (q2 - q1) &lt; 1 and since q2 - q1 is an integer it must be 0. => q1 = q2 and r1 = r2 thereby completing the proof.</p><h3 id=the-eucledian-algorithm>The Eucledian Algorithm<a hidden class=anchor aria-hidden=true href=#the-eucledian-algorithm>#</a></h3><p>Now, lets start interacting with the gcd and take the first step towards euclids algorithm. We first introduce a lemma which will more or less pave the way to the actual algorithm.</p><p><strong>Lemma</strong>: If a = bq + r then gcd(a, b) = gcd(b, r).</p><p><strong>Proof</strong>: This statement did not look obvious to me at least in anyway. So the only way to convince ourselves that this is true is by proving it.</p><p>Lets say gcd(a, b) = d => d | a and d | b also for all e such that e | a and e | b, e | d. (note that this is actually the definition of GCD expressed in mathematical terms)</p><p>Now if d | a and d | b => d | a - bq => d | r. So d is definitely a candidate to be the gcd(b, r) since it divides both b and r.
But we don&rsquo;t know if it is the highest such divisor. Lets assume its not and assume that there is an integer e which is the gcd(b, r) => e | b and e | r. So e | bq + r => e | a.
Now gcd(a, b) = d. And since e | a and e | b, e &lt;= d. Since if e > d, then e should have been the gcd of a and b. This proves that d is also the gcd(b, r) thereby proving the lemma.</p><p>Now that we have proved this seemingly unintuitive result, here comes the masterstroke step of euclids algorithm. We apply the division algorithm repeatedly, giving us the following set of equations:</p><p>a = bq + r, 0 &lt; r &lt; b
b = rq1 + r1, 0 &lt; r1 &lt; r
r = r1q2 + r2, 0 &lt; r2 &lt; r1
r1 = r2q3 + r3, 0 &lt; r3 &lt; r2
.
.
.
rn-1= rnqn+1 + rn+1, where rn+1 = 0.</p><p>Basically we claim that since the remainders, r1, r2 etc. are strictly decreasing, it will become 0 after n number of steps. (max b steps to be precise).</p><p>Now if we apply the above gcd lemma to these equations sequentially we will get the following:</p><p>gcd(a, b) = gcd(b, r) = gcd(r, r1) &mldr; = gcd(rn-1, rn) = gcd(rn, 0) = rn</p><p>The above statement basically gives us a new method of finding the gcd of two numbers. Simply put, it says to apply the division algorithm repeatedly to the numbers and once the remainder becomes 0 (which it eventually will), the quotient at that stage is the gcd.</p><p>Here is the 3 line method of GCD calculation now.</p><figure><img loading=lazy src=/images/gcd.png></figure><p>If you understand recursion well. shouldn&rsquo;t be hard to see how this is exactly the code conversion of the process illustrated above and why this should give the GCD.</p><h3 id=complexity-analysis>Complexity analysis<a hidden class=anchor aria-hidden=true href=#complexity-analysis>#</a></h3><p>The time complexity of this method is log(max(a, b)). So basically logarithmic. I tried reading the proof of this but it is a bit complicated. Turns out the worst case happens with consecutive fibonaaci numbers and is related to the golden ration. Definitely seems like a good thing to explore.
However not going to do that in this post. Anyway, I will have to read about it first myself to get a proper understanding. Maybe in a future post..</p><p><strong>Update</strong>: Read around a bit and found a few sources. This is the concrete analysis of the runtime as given by Knuth in his TOACP book. I found it to be very involved and difficult to understand. Feel free to give it a shot if you want.
This on the other hand is a little less rigorous but still a good proof of the logarithmic runtime. It uses very simple arguments and shouldn&rsquo;t be hard to understand. Feel free to go through it.</p><p>Hopefully this post gives you more confidence in using the Euclidean method of finding the GCD from now on. And even if you never use it, who cares. What would matter is how the proof made you feel and not if it was useful :)</p></div><footer class=post-footer><ul class=post-tags></ul></footer></article></main><footer class=footer><span>&copy; 2024 <a href=https://tanayjha.github.io/></a></span><span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>