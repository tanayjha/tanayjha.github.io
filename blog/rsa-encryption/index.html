<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>RSA Encryption System | </title><meta name=keywords content><meta name=description content="THE NEED OF ENCRYPTION In today&rsquo;s world where a lot of secured information like our credit card number, passwords etc., travel around the web, the presence of a secure encryption system is almost inevitable.
We want a method to encrypt a message, send it over the insecure internet connection and allow only the receiver to be able to decrypt and read the original message. This exact problem was solved by Rivest, Shamir and Adleman(RSA) in the year 1978, in their paper A Method for Obtaining Digital Signatures and Public-Key Cryptosystems."><meta name=author content><link rel=canonical href=https://tanayjha.github.io/blog/rsa-encryption/><link crossorigin=anonymous href=/assets/css/stylesheet.d7fb4cbf980fe688a21621b06a795933c4e6bb2d4070ec940667af1715d84af2.css integrity="sha256-1/tMv5gP5oiiFiGwanlZM8Tmuy1AcOyUBmevFxXYSvI=" rel="preload stylesheet" as=style><script defer crossorigin=anonymous src=/assets/js/highlight.f413e19d0714851f6474e7ee9632408e58ac146fbdbe62747134bea2fa3415e0.js integrity="sha256-9BPhnQcUhR9kdOfuljJAjlisFG+9vmJ0cTS+ovo0FeA=" onload=hljs.initHighlightingOnLoad()></script><link rel=icon href=https://tanayjha.github.io/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://tanayjha.github.io/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://tanayjha.github.io/favicon-32x32.png><link rel=apple-touch-icon href=https://tanayjha.github.io/apple-touch-icon.png><link rel=mask-icon href=https://tanayjha.github.io/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=en href=https://tanayjha.github.io/blog/rsa-encryption/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--hljs-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><meta property="og:title" content="RSA Encryption System"><meta property="og:description" content="THE NEED OF ENCRYPTION In today&rsquo;s world where a lot of secured information like our credit card number, passwords etc., travel around the web, the presence of a secure encryption system is almost inevitable.
We want a method to encrypt a message, send it over the insecure internet connection and allow only the receiver to be able to decrypt and read the original message. This exact problem was solved by Rivest, Shamir and Adleman(RSA) in the year 1978, in their paper A Method for Obtaining Digital Signatures and Public-Key Cryptosystems."><meta property="og:type" content="article"><meta property="og:url" content="https://tanayjha.github.io/blog/rsa-encryption/"><meta property="article:section" content="blog"><meta property="article:published_time" content="2017-04-22T12:09:25+05:30"><meta property="article:modified_time" content="2017-04-22T12:09:25+05:30"><meta name=twitter:card content="summary"><meta name=twitter:title content="RSA Encryption System"><meta name=twitter:description content="THE NEED OF ENCRYPTION In today&rsquo;s world where a lot of secured information like our credit card number, passwords etc., travel around the web, the presence of a secure encryption system is almost inevitable.
We want a method to encrypt a message, send it over the insecure internet connection and allow only the receiver to be able to decrypt and read the original message. This exact problem was solved by Rivest, Shamir and Adleman(RSA) in the year 1978, in their paper A Method for Obtaining Digital Signatures and Public-Key Cryptosystems."><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Blogs","item":"https://tanayjha.github.io/blog/"},{"@type":"ListItem","position":2,"name":"RSA Encryption System","item":"https://tanayjha.github.io/blog/rsa-encryption/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"RSA Encryption System","name":"RSA Encryption System","description":"THE NEED OF ENCRYPTION In today\u0026rsquo;s world where a lot of secured information like our credit card number, passwords etc., travel around the web, the presence of a secure encryption system is almost inevitable.\nWe want a method to encrypt a message, send it over the insecure internet connection and allow only the receiver to be able to decrypt and read the original message. This exact problem was solved by Rivest, Shamir and Adleman(RSA) in the year 1978, in their paper A Method for Obtaining Digital Signatures and Public-Key Cryptosystems.","keywords":[],"articleBody":"THE NEED OF ENCRYPTION In today’s world where a lot of secured information like our credit card number, passwords etc., travel around the web, the presence of a secure encryption system is almost inevitable.\nWe want a method to encrypt a message, send it over the insecure internet connection and allow only the receiver to be able to decrypt and read the original message. This exact problem was solved by Rivest, Shamir and Adleman(RSA) in the year 1978, in their paper A Method for Obtaining Digital Signatures and Public-Key Cryptosystems. In this post, I will try to explain the method they adopted to create a secure encryption system.\nPUBLIC KEY CRYPTOSYSTEM A public key cryptosystem has the following properties:\nD(E(M)) = M, if we decrypt an encrypted message, we should get back the message.\nBoth E and D should be easy to compute, if it takes days to encrypt or decrypt the message, then the cryptosystem is not very useful.\nBy publicly revealing E the user does not reveal an easy way to compute D. The encryption key of the users is revealed publicly so that any person can send an encrypted message to the user. However if by using E, someone can obtain D, then the encryption system will fail. So this should not happen.\nE(D(M) = M, i.e it is a trap-door one-way permutation. Trap-door, as there is a method to decrypt the message. One-way as by revealing E, we do not reveal D. Permutation as we get back the message by decrypting an encrypted message or encrypting a decrypted message. This property is useful in digital signatures.\nIn the above image, we can observe how data is transferred between the sender and the receiver. The sender uses the recipients encryption key to encrypt the message. This transforms the plaintext message to ciphertext. This ciphertext is then sent over the insecure connection to the recipient, who can decrypt the message using his own decryption key, which is exclusive to him.\nDIGITAL SIGNATURES Digital signatures have become commonplace nowadays. They present a very efficient method of saving resources as well as time. However, we require a secure system in place as the signed documents have to be sent over an insecure connection and digital forgery is fairly easy. Rivest, Shamir and Adleman presented a very elegant method to solve the problem of digital signature in their paper. Here we describe the method.\nBob has to send a signed document(M) to Alice\nS = DB(M), Bob uses his decryption key on the message(i,e the document) to create a unique signature.\nHe sends EA(S) to Alice. He encrypts the message using Alice’s encryption key to ensure secure communication.\nAlice decrypts the received ciphertext with DA to obtain S.\nNow Alice uses Bob’s encryption key on S, i.e EB(S), and if the original document is obtained then it ensures that Bob was the one who signed the document as DB is present only with Bob.\nHence the above method provides a way to legally ensure that a signature can be linked to a particular person. However, we still have to talk about digital forgery. What if someone copy pastes Bob’s signature to another document, say M’. We have nothing to worry about because Bob’s signature created in the first step, not only links it to Bob, but also to the document (M) itself. So if the document changes from M to M’, Bob’s signature will also change from S to S’. Hence a single signature cannot be used on multiple documents and hence forgery of the signatures is not possible.\nTHE IDEA The main idea behind the RSA Encryption System is that factorization is a hard problem. Specifically, if we are given the product of two prime numbers and are asked to find the individual primes which consist of the product, then the best known algorithm to do this is Number Field Sieve (NFS). The running time of NFS is O(n1/3) for an integer n. It is easy to create a product of primes as long as 10^2048. However we can contemplate, how long it will take to obtain the two primes whose product is given.\nThere was a challenge held till 2007, in which the participants were provided with the number n = p * q, p and q are prime and the participants had to find p and q. The number n was called the RSA number. RSA-220(220 digits long) was solved last year!\nEULER TOTIENT FUNCTION To understand the math that will follow we have to understand what is the euler totient function. φ(n) is the euler totient function, it gives the number of positive integers less than n which are relatively prime to n, i.e gcd(number, n) = 1. So for example φ(4) = 2 ({1, 3}, gcd(1, 4) = 1 and gcd(3, 4) = 1 but gcd(2, 4) ≠ 1.) Similarly φ(5) = ({1, 2, 3, 4}, gcd(i, 5) = 1 ∀ i ∈ {1, 2, 3, 4})\nWe can observe that for every prime p, φ(p) = p-1 (as gcd(i, p) = 1 ∀ i ∈ {1, 2, 3…p-1})\nLets try to calculate the totient function for product of primes, say pq\nφ(pq) = (pq − 1) − (p − 1) − (q − 1) …. (1) pq-1 is the number of numbers less than pq. However there are (p-1) multiples of q among those which will not have a gcd of 1 with pq, similarly there are (q-1) multiples of p which will not have a gcd of 1 with pq. So by subtracting these two quantities from all possible numbers, we get the numbers which have a gcd 1 with pq, which is exactly the value of Euler Totient Function Simplifying the above equation we get φ(pq) = pq − p − q + 1 ……. (2) φ(pq) = (p − 1)(q − 1) ……. (3)\nTHE METHOD Bob chooses two primes p,q and compute n=pq\nBob chooses d with gcd(d , (p-1)(q-1)) = gcd(d , φ(n))=1\nBob solves de ≡ 1 (mod φ(n)) and gets e\nBob makes (e,n) public and keeps (p,q,d) private\nAlice encrypts M as C ≡ Me(mod n)\nBob decrypts by computing M ≡ Cd(mod n)\nTHE UNDERLYING MATHEMATICS We have to show that the above mentioned method of encrypting and decrypting the message will provide us a way to get D(E(M)) = M and E(D(M) = M Now, D(E(M)) ≡ (E(M))d ≡ (Me)d(mod n) = Me·d(mod n) ….. (4)\nE(D(M)) ≡ (D(M))e ≡ (Md)e(mod n) = Me·d(mod n) ….. (5)\nSo we observe that both the quantities reduce to the same expression. If we somehow prove that Me·d(mod n) ≡ M(mod n), we will be done.\nMe·d ≡ Mk·φ(n)+1(mod n) (for some integer k) …….. (6) This follows from the fact that de ≡ 1 (mod φ(n))\nNow Fermat’s little theorem states that Mφ(p) ≡ 1 (mod p) …… (7)\nFrom (6) and (7), we get,\nMk·φ(n)+1 ≡ (Mφ(n))k .M ≡ 1k.M (mod p) ≡ M (mod p) ….. (8)\nMk·φ(n)+1 ≡ (Mφ(n))k .M ≡ 1k.M (mod q) ≡ M (mod q) ….. (9)\nNow we have to somehow combine (8) and (9) to obtain the result (mod n).\nSimplifying (8) and (9), we have something of the form\na ≡ b (mod p) =\u003e p | (a-b) (p divides a-b)\na ≡ b (mod q) =\u003e q | (a-b) (q divides a-b)\nWe claim that we can combine the above two equations to give:\na ≡ b (mod n) =\u003e n | (a-b) (n divides a-b) (where n = p * q)\nThis follows easily because p and q are prime and they divide (a-b). Hence if we express the prime factorization of (a-b), it will contain at least two primes which are p and q respectively. i,e (a-b) = (pq)p1p2…. It is clear from the above argument that pq= n occurs in the prime factorization of (a-b) =\u003e n (= p*q) | (a-b) thereby proving the combination property.\nUsing the above proved fact we can combine (8) and (9) to give:\nMe·d ≡ Mk·φ(n)+1 ≡ M (mod n) …….. (10)\nHence we have proved that the RSA system of encryption works and due to the permutation property((4) and (5)), the problem of digital signatures is also resolved.\nA SMALL EXAMPLE Consider the case:\np = 47, q = 59, n = p · q = 47 · 59 = 2773, φ(2773) = 46 · 58 = 2668 and d = 157 e = 17, as 17.157 ≡ 1(mod 2668)\nLet the message be:\nITS ALL GREEK TO ME\nWe convert this by substituting a two digit number for each letter, blank = 00, A = 01, B = 02, . . . , Z = 26\nThe converted string is: 0920 1900 0112 1200 0718 0505 1100 2015 0013 0500\nThe first block(M=920) can be enciphered as:\nM17 = ((((M)2)2)2)2 ·M = 948 (mod 2773)\nThe whole message is enciphered as: 0948 2342 1084 1444 2663 2390 0778 0774 0219 1655\nDeciphering the first block gives:\n948157 ≡ 920 (mod 2773)\nIn the same way we can decipher all the blocks and apply reverse substitution to get back the original message.\nTHE LEGEND OF RSA The RSA algorithm has remained a secure scheme for sending encrypted messages for almost 40 years, earning Rivest, Shamir, and Adleman the Association for Computing Machinery’s 2002 Alan Turing Award, among one of the highest honors in computer science!\n","wordCount":"1578","inLanguage":"en","datePublished":"2017-04-22T12:09:25+05:30","dateModified":"2017-04-22T12:09:25+05:30","mainEntityOfPage":{"@type":"WebPage","@id":"https://tanayjha.github.io/blog/rsa-encryption/"},"publisher":{"@type":"Organization","name":"","logo":{"@type":"ImageObject","url":"https://tanayjha.github.io/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button><ul class=lang-switch><li>|</li></ul></div></div><ul id=menu></ul></nav></header><main class=main><article class=post-single><header class=post-header><h1 class=post-title>RSA Encryption System</h1><div class=post-meta>&lt;span title='2017-04-22 12:09:25 +0530 +0530'>April 22, 2017&lt;/span>&amp;nbsp;·&amp;nbsp;8 min</div></header><div class=toc><details><summary accesskey=c title="(Alt + C)"><span class=details>Table of Contents</span></summary><div class=inner><ul><li><a href=#the-need-of-encryption aria-label="THE NEED OF ENCRYPTION">THE NEED OF ENCRYPTION</a></li><li><a href=#public-key-cryptosystem aria-label="PUBLIC KEY CRYPTOSYSTEM">PUBLIC KEY CRYPTOSYSTEM</a></li><li><a href=#digital-signatures aria-label="DIGITAL SIGNATURES">DIGITAL SIGNATURES</a></li><li><a href=#the-idea aria-label="THE IDEA">THE IDEA</a></li><li><a href=#euler-totient-function aria-label="EULER TOTIENT FUNCTION">EULER TOTIENT FUNCTION</a></li><li><a href=#the-method aria-label="THE METHOD">THE METHOD</a></li><li><a href=#the-underlying-mathematics aria-label="THE UNDERLYING MATHEMATICS">THE UNDERLYING MATHEMATICS</a></li><li><a href=#a-small-example aria-label="A SMALL EXAMPLE">A SMALL EXAMPLE</a></li><li><a href=#the-legend-of-rsa aria-label="THE LEGEND OF RSA">THE LEGEND OF RSA</a></li></ul></div></details></div><div class=post-content><h3 id=the-need-of-encryption>THE NEED OF ENCRYPTION<a hidden class=anchor aria-hidden=true href=#the-need-of-encryption>#</a></h3><p>In today&rsquo;s world where a lot of secured information like our credit card number, passwords etc., travel around the web, the presence of a secure encryption system is almost inevitable.</p><p><strong>We want a method to encrypt a message, send it over the insecure internet connection and allow only the receiver to be able to decrypt and read the original message.</strong> This exact problem was solved by Rivest, Shamir and Adleman(RSA) in the year 1978, in their paper A Method for Obtaining Digital Signatures and Public-Key Cryptosystems.
In this post, I will try to explain the method they adopted to create a secure encryption system.</p><h3 id=public-key-cryptosystem>PUBLIC KEY CRYPTOSYSTEM<a hidden class=anchor aria-hidden=true href=#public-key-cryptosystem>#</a></h3><p>A public key cryptosystem has the following properties:</p><ol><li><p>D(E(M)) = M, if we decrypt an encrypted message, we should get back the message.</p></li><li><p>Both E and D should be easy to compute, if it takes days to encrypt or decrypt the message, then the cryptosystem is not very useful.</p></li><li><p>By publicly revealing E the user does not reveal an easy way to compute D. The encryption key of the users is revealed publicly so that any person can send an encrypted message to the user. However if by using E, someone can obtain D, then the encryption system will fail. So this should not happen.</p></li><li><p>E(D(M) = M, i.e it is a <strong>trap-door one-way permutation</strong>. Trap-door, as there is a method to decrypt the message. One-way as by revealing E, we do not reveal D. Permutation as we get back the message by decrypting an encrypted message or encrypting a decrypted message. This property is useful in digital signatures.</p></li></ol><figure><img loading=lazy src=/images/rsa.png></figure><p>In the above image, we can observe how data is transferred between the sender and the receiver. The sender uses the recipients encryption key to encrypt the message. This transforms the plaintext message to ciphertext. This ciphertext is then sent over the insecure connection to the recipient, who can decrypt the message using his own decryption key, which is exclusive to him.</p><h3 id=digital-signatures>DIGITAL SIGNATURES<a hidden class=anchor aria-hidden=true href=#digital-signatures>#</a></h3><p>Digital signatures have become commonplace nowadays. They present a very efficient method of saving resources as well as time. However, we require a secure system in place as the signed documents have to be sent over an insecure connection and digital forgery is fairly easy.
Rivest, Shamir and Adleman presented a very elegant method to solve the problem of digital signature in their paper. Here we describe the method.</p><p>Bob has to send a signed document(M) to Alice</p><ol><li><p>S = DB(M), Bob uses his decryption key on the message(i,e the document) to create a unique signature.</p></li><li><p>He sends EA(S) to Alice. He encrypts the message using Alice&rsquo;s encryption key to ensure secure communication.</p></li><li><p>Alice decrypts the received ciphertext with DA to obtain S.</p></li><li><p>Now Alice uses Bob&rsquo;s encryption key on S, i.e EB(S), and if the original document is obtained then it ensures that Bob was the one who signed the document as DB is present only with Bob.</p></li></ol><p>Hence the above method provides a way to legally ensure that a signature can be linked to a particular person.
However, we still have to talk about digital forgery. What if someone copy pastes Bob&rsquo;s signature to another document, say M&rsquo;.
We have nothing to worry about because Bob&rsquo;s signature created in the first step, not only links it to Bob, but also to the document (M) itself. So if the document changes from M to M&rsquo;, Bob&rsquo;s signature will also change from S to S&rsquo;. Hence a single signature cannot be used on multiple documents and hence forgery of the signatures is not possible.</p><h3 id=the-idea>THE IDEA<a hidden class=anchor aria-hidden=true href=#the-idea>#</a></h3><p>The main idea behind the RSA Encryption System is that factorization is a hard problem.
Specifically, if we are given the product of two prime numbers and are asked to find the individual primes which consist of the product, then the best known algorithm to do this is Number Field Sieve (NFS).
The running time of NFS is O(n1/3) for an integer n.
It is easy to create a product of primes as long as 10^2048. However we can contemplate, how long it will take to obtain the two primes whose product is given.</p><p>There was a challenge held till 2007, in which the participants were provided with the number n = p * q, p and q are prime and the participants had to find p and q. The number n was called the RSA number.
<strong>RSA-220(220 digits long) was solved last year!</strong></p><h3 id=euler-totient-function>EULER TOTIENT FUNCTION<a hidden class=anchor aria-hidden=true href=#euler-totient-function>#</a></h3><p>To understand the math that will follow we have to understand what is the euler totient function.
<strong>φ(n) is the euler totient function, it gives the number of positive integers less than n which are relatively prime to n, i.e gcd(number, n) = 1.</strong>
So for example φ(4) = 2 ({1, 3}, gcd(1, 4) = 1 and gcd(3, 4) = 1 but gcd(2, 4) ≠ 1.)
Similarly φ(5) = ({1, 2, 3, 4}, gcd(i, 5) = 1 ∀ i ∈ {1, 2, 3, 4})</p><p>We can observe that for every prime p, φ(p) = p-1 (as gcd(i, p) = 1 ∀ i ∈ {1, 2, 3&mldr;p-1})</p><p>Lets try to calculate the totient function for product of primes, say pq</p><p>φ(pq) = (pq − 1) − (p − 1) − (q − 1) &mldr;. (1)
pq-1 is the number of numbers less than pq. However there are (p-1) multiples of q among those which will not have a gcd of 1 with pq, similarly there are (q-1) multiples of p which will not have a gcd of 1 with pq. So by subtracting these two quantities from all possible numbers, we get the numbers which have a gcd 1 with pq, which is exactly the value of Euler Totient Function
Simplifying the above equation we get
<strong>φ(pq) = pq − p − q + 1 &mldr;&mldr;. (2)
φ(pq) = (p − 1)(q − 1) &mldr;&mldr;. (3)</strong></p><h3 id=the-method>THE METHOD<a hidden class=anchor aria-hidden=true href=#the-method>#</a></h3><ul><li><p>Bob chooses two primes p,q and compute n=pq</p></li><li><p>Bob chooses d with gcd(d , (p-1)(q-1)) = gcd(d , φ(n))=1</p></li><li><p>Bob solves de ≡ 1 (mod φ(n)) and gets e</p></li><li><p>Bob makes (e,n) public and keeps (p,q,d) private</p></li><li><p>Alice encrypts M as C ≡ Me(mod n)</p></li><li><p>Bob decrypts by computing M ≡ Cd(mod n)</p></li></ul><h3 id=the-underlying-mathematics>THE UNDERLYING MATHEMATICS<a hidden class=anchor aria-hidden=true href=#the-underlying-mathematics>#</a></h3><p>We have to show that the above mentioned method of encrypting and decrypting the message will provide us a way to get D(E(M)) = M and E(D(M) = M
Now,
<strong>D(E(M)) ≡ (E(M))<sup>d</sup> ≡ (M<sup>e</sup>)<sup>d</sup>(mod n) = M<sup>e·d</sup>(mod n) &mldr;.. (4)</strong></p><p><strong>E(D(M)) ≡ (D(M))<sup>e</sup> ≡ (M<sup>d</sup>)<sup>e</sup>(mod n) = M<sup>e·d</sup>(mod n) &mldr;.. (5)</strong></p><p>So we observe that both the quantities reduce to the same expression.
If we somehow prove that Me·d(mod n) ≡ M(mod n), we will be done.</p><p><strong>M<sup>e·d</sup> ≡ M<sup>k·φ(n)+1</sup>(mod n) (for some integer k) &mldr;&mldr;.. (6)</strong>
This follows from the fact that de ≡ 1 (mod φ(n))</p><p>Now <a href=https://primes.utm.edu/notes/proofs/FermatsLittleTheorem.html>Fermat&rsquo;s little theorem</a> states that Mφ(p) ≡ 1 (mod p) &mldr;&mldr; (7)</p><p>From (6) and (7), we get,</p><p><strong>M<sup>k·φ(n)+1</sup> ≡ (Mφ(n))<sup>k</sup> .M ≡ 1<sup>k</sup>.M (mod p) ≡ M (mod p) &mldr;.. (8)</strong></p><p><strong>M<sup>k·φ(n)+1</sup> ≡ (Mφ(n))<sup>k</sup> .M ≡ 1<sup>k</sup>.M (mod q) ≡ M (mod q) &mldr;.. (9)</strong></p><p>Now we have to somehow combine (8) and (9) to obtain the result (mod n).</p><p>Simplifying (8) and (9), we have something of the form</p><p>a ≡ b (mod p) => p | (a-b) (p divides a-b)<br>a ≡ b (mod q) => q | (a-b) (q divides a-b)</p><p>We claim that we can combine the above two equations to give:</p><p>a ≡ b (mod n) => n | (a-b) (n divides a-b) (where n = p * q)</p><p>This follows easily because p and q are prime and they divide (a-b).
Hence if we express the prime factorization of (a-b), it will contain at least two primes which are p and q respectively.
i,e (a-b) = (p<em>q)<em>p1</em>p2&mldr;.
It is clear from the above argument that p</em>q= n occurs in the prime factorization of (a-b) => n (= p*q) | (a-b) thereby proving the combination property.</p><p>Using the above proved fact we can combine (8) and (9) to give:</p><p><strong>M<sup>e·d</sup> ≡ M<sup>k·φ(n)+1</sup> ≡ M (mod n) &mldr;&mldr;.. (10)</strong></p><p>Hence we have proved that the RSA system of encryption works and due to the permutation property((4) and (5)), the problem of digital signatures is also resolved.</p><h3 id=a-small-example>A SMALL EXAMPLE<a hidden class=anchor aria-hidden=true href=#a-small-example>#</a></h3><p>Consider the case:</p><p><strong>p = 47, q = 59, n = p · q = 47 · 59 = 2773, φ(2773) = 46 · 58 = 2668 and d = 157 e = 17, as 17.157 ≡ 1(mod 2668)</strong></p><p>Let the message be:</p><p><strong>ITS ALL GREEK TO ME</strong></p><p>We convert this by substituting a two digit number for each letter, blank = 00, A = 01, B = 02, . . . , Z = 26</p><p>The converted string is:
<strong>0920 1900 0112 1200 0718 0505 1100 2015 0013 0500</strong></p><p>The first block(M=920) can be enciphered as:</p><p>M17 = ((((M)2)2)2)2 ·M = 948 (mod 2773)</p><p>The whole message is enciphered as:
<strong>0948 2342 1084 1444 2663 2390 0778 0774 0219 1655</strong></p><p>Deciphering the first block gives:</p><p>948157 ≡ 920 (mod 2773)</p><p>In the same way we can decipher all the blocks and apply reverse substitution to get back the original message.</p><h3 id=the-legend-of-rsa>THE LEGEND OF RSA<a hidden class=anchor aria-hidden=true href=#the-legend-of-rsa>#</a></h3><p>The RSA algorithm has remained a secure scheme for sending encrypted messages for almost 40 years, earning Rivest, Shamir, and Adleman the Association for Computing Machinery’s 2002 Alan Turing Award, among one of the highest honors in computer science!</p></div><footer class=post-footer><ul class=post-tags></ul></footer></article></main><footer class=footer><span>&copy; 2024 <a href=https://tanayjha.github.io/></a></span><span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>