<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Detecting starting point of loop in a linked list | </title><meta name=keywords content><meta name=description content="Detecting the starting point of a loop in a linked list is a very popular problem. In fact most you reading this might already be knowing the algorithm to solve this. However understanding why that algorithm works is a separate challenge altogether.
I was in the same state and decided to find an explanation of why it works. I could not find convincing explanations by simple google searches and hence decided to right this blog."><meta name=author content><link rel=canonical href=https://tanayjha.github.io/blog/starting-point-linked-list/><link crossorigin=anonymous href=/assets/css/stylesheet.d7fb4cbf980fe688a21621b06a795933c4e6bb2d4070ec940667af1715d84af2.css integrity="sha256-1/tMv5gP5oiiFiGwanlZM8Tmuy1AcOyUBmevFxXYSvI=" rel="preload stylesheet" as=style><script defer crossorigin=anonymous src=/assets/js/highlight.f413e19d0714851f6474e7ee9632408e58ac146fbdbe62747134bea2fa3415e0.js integrity="sha256-9BPhnQcUhR9kdOfuljJAjlisFG+9vmJ0cTS+ovo0FeA=" onload=hljs.initHighlightingOnLoad()></script><link rel=icon href=https://tanayjha.github.io/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://tanayjha.github.io/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://tanayjha.github.io/favicon-32x32.png><link rel=apple-touch-icon href=https://tanayjha.github.io/apple-touch-icon.png><link rel=mask-icon href=https://tanayjha.github.io/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=en href=https://tanayjha.github.io/blog/starting-point-linked-list/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--hljs-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><meta property="og:title" content="Detecting starting point of loop in a linked list"><meta property="og:description" content="Detecting the starting point of a loop in a linked list is a very popular problem. In fact most you reading this might already be knowing the algorithm to solve this. However understanding why that algorithm works is a separate challenge altogether.
I was in the same state and decided to find an explanation of why it works. I could not find convincing explanations by simple google searches and hence decided to right this blog."><meta property="og:type" content="article"><meta property="og:url" content="https://tanayjha.github.io/blog/starting-point-linked-list/"><meta property="article:section" content="blog"><meta property="article:published_time" content="2019-06-06T12:01:25+05:30"><meta property="article:modified_time" content="2019-06-06T12:01:25+05:30"><meta name=twitter:card content="summary"><meta name=twitter:title content="Detecting starting point of loop in a linked list"><meta name=twitter:description content="Detecting the starting point of a loop in a linked list is a very popular problem. In fact most you reading this might already be knowing the algorithm to solve this. However understanding why that algorithm works is a separate challenge altogether.
I was in the same state and decided to find an explanation of why it works. I could not find convincing explanations by simple google searches and hence decided to right this blog."><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Blogs","item":"https://tanayjha.github.io/blog/"},{"@type":"ListItem","position":2,"name":"Detecting starting point of loop in a linked list","item":"https://tanayjha.github.io/blog/starting-point-linked-list/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Detecting starting point of loop in a linked list","name":"Detecting starting point of loop in a linked list","description":"Detecting the starting point of a loop in a linked list is a very popular problem. In fact most you reading this might already be knowing the algorithm to solve this. However understanding why that algorithm works is a separate challenge altogether.\nI was in the same state and decided to find an explanation of why it works. I could not find convincing explanations by simple google searches and hence decided to right this blog.","keywords":[],"articleBody":"Detecting the starting point of a loop in a linked list is a very popular problem. In fact most you reading this might already be knowing the algorithm to solve this. However understanding why that algorithm works is a separate challenge altogether.\nI was in the same state and decided to find an explanation of why it works. I could not find convincing explanations by simple google searches and hence decided to right this blog. Hopefully, this will satisfy the curiosity of people trying to understand the reasoning behind this algorithm.\nI believe coming up with this algorithm in the first place is an even bigger challenge. You will have to stay with this problem a lot longer if you want to do that. For now let’s assume we have the algorithm and let’s try to prove why it should work.\nThe Algorithm The key insight of the algorithm is that we need to maintain two pointers: Slow and Fast,\nSlow pointer: Moves one node at a time. Fast pointer: Moves two nodes at a time.\nThe first thing to realise is that these pointers are definitely going to meet at some position in the loop. To convince yourself, consider this:\nBoth the pointers are going to enter the loop at some point. The fast pointer will catch up with the slow pointer one step at a time (since it moves at double the speed) Above diagram shows an example of a loop.\nNow we know that the pointers are going to meet at some point in the loop.\nThe second step of the algorithm says that bring one of the pointers to the start of the list. Now move both the pointers (one at the start and one at the meeting point in the loop) one step at a time. The next time they meet will be the starting point of the list.\nLet’s try to prove this algorithm.\nProof We need to consider certain variables to mathematically formulate the problem.\nm - number of links a pointer has to travel to reach the starting point of the loop l - the number of links a pointer has to travel to complete one cycle of the loop k - the number of links a pointer has to travel from the starting point of the loop to reach the meeting point of the nodes in the first step of the algorithm.\nNow that we have defined these variables, let us consider the following:\nDistance travelled by the slow pointer to reach the meeting point = m + p * l + k\nm is the distance travelled to reach the starting of the loop. Let’s say it makes p rounds of the loop (notice that p can be zero) and finally it travels k distance from the loop start to reach the meeting point.\nDistance travelled by the slow pointer to reach the meeting point = m + q * l + k\nThis is similar to the slow pointer except that the fast pointer makes q rounds of the loop. Since it travels at twice the speed hence q \u003e p.\nNow we know that, distance travelled by fast pointer = 2 * distance travelled by slow pointer\nSo, m + q * l + k = 2 * (m + p * l + k) =\u003e (m + k) = (q - 2 * p) * l\nWhat this means is that (m + k) is an integral multiple of the length of the loop or in other words, (m+k) % l = 0. So if you travel a distance of (m+k) in the loop, you will reach the start of the loop.\nNow we can consider the second part of the algorithm. We bring one pointer to the start of the list. Now when this pointer takes m steps, it reaches the start of the loop. How much distance would the second pointer have covered by this time? It would be m+k. Why? Since it was already at an offset k after the first step of the algorithm and then it travels m more steps.\nNow we know that (m+k) is a multiple of l. That means the second pointer has reached the start of the loop and so has the first pointer. This implies that both the pointer will meet at the beginning of the loop after the second step of the algorithm. Hence the algorithm works.\nCredit\n","wordCount":"742","inLanguage":"en","datePublished":"2019-06-06T12:01:25+05:30","dateModified":"2019-06-06T12:01:25+05:30","mainEntityOfPage":{"@type":"WebPage","@id":"https://tanayjha.github.io/blog/starting-point-linked-list/"},"publisher":{"@type":"Organization","name":"","logo":{"@type":"ImageObject","url":"https://tanayjha.github.io/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button><ul class=lang-switch><li>|</li></ul></div></div><ul id=menu></ul></nav></header><main class=main><article class=post-single><header class=post-header><h1 class=post-title>Detecting starting point of loop in a linked list</h1><div class=post-meta>&lt;span title='2019-06-06 12:01:25 +0530 +0530'>June 6, 2019&lt;/span>&amp;nbsp;·&amp;nbsp;4 min</div></header><div class=toc><details><summary accesskey=c title="(Alt + C)"><span class=details>Table of Contents</span></summary><div class=inner><ul><li><a href=#the-algorithm aria-label="The Algorithm">The Algorithm</a></li><li><a href=#proof aria-label=Proof>Proof</a></li></ul></div></details></div><div class=post-content><p>Detecting the starting point of a loop in a linked list is a very popular problem. In fact most you reading this might already be knowing the algorithm to solve this. However understanding why that algorithm works is a separate challenge altogether.</p><p>I was in the same state and decided to find an explanation of why it works. I could not find convincing explanations by simple google searches and hence decided to right this blog.
Hopefully, this will satisfy the curiosity of people trying to understand the reasoning behind this algorithm.</p><p>I believe coming up with this algorithm in the first place is an even bigger challenge. You will have to stay with this problem a lot longer if you want to do that. For now let&rsquo;s assume we have the algorithm and let&rsquo;s try to prove why it should work.</p><h3 id=the-algorithm>The Algorithm<a hidden class=anchor aria-hidden=true href=#the-algorithm>#</a></h3><p>The key insight of the algorithm is that we need to maintain two pointers: Slow and Fast,</p><p>Slow pointer: Moves one node at a time.
Fast pointer: Moves two nodes at a time.</p><p>The first thing to realise is that these pointers are definitely going to meet at some position in the loop. To convince yourself, consider this:</p><ul><li>Both the pointers are going to enter the loop at some point.</li><li>The fast pointer will catch up with the slow pointer one step at a time (since it moves at double the speed)</li></ul><figure><img loading=lazy src=/images/linkedList.png></figure><p>Above diagram shows an example of a loop.</p><p>Now we know that the pointers are going to meet at some point in the loop.</p><p>The second step of the algorithm says that bring one of the pointers to the start of the list.
Now move both the pointers (one at the start and one at the meeting point in the loop) one step at a time. <strong>The next time they meet will be the starting point of the list.</strong></p><p>Let&rsquo;s try to prove this algorithm.</p><h3 id=proof>Proof<a hidden class=anchor aria-hidden=true href=#proof>#</a></h3><p>We need to consider certain variables to mathematically formulate the problem.</p><p>m - number of links a pointer has to travel to reach the starting point of the loop
l - the number of links a pointer has to travel to complete one cycle of the loop
k - the number of links a pointer has to travel from the starting point of the loop to reach the meeting point of the nodes in the first step of the algorithm.</p><p>Now that we have defined these variables, let us consider the following:</p><p><strong>Distance travelled by the slow pointer to reach the meeting point = m + p * l + k</strong></p><p>m is the distance travelled to reach the starting of the loop. Let&rsquo;s say it makes p rounds of the loop (notice that p can be zero) and finally it travels k distance from the loop start to reach the meeting point.</p><p><strong>Distance travelled by the slow pointer to reach the meeting point = m + q * l + k</strong></p><p>This is similar to the slow pointer except that the fast pointer makes q rounds of the loop. Since it travels at twice the speed hence q > p.</p><p>Now we know that, distance travelled by fast pointer = 2 * distance travelled by slow pointer</p><p>So, <strong>m + q * l + k = 2 * (m + p * l + k) => (m + k) = (q - 2 * p) * l</strong></p><p>What this means is that (m + k) is an integral multiple of the length of the loop or in other words, (m+k) % l = 0. So if you travel a distance of (m+k) in the loop, you will reach the start of the loop.</p><p>Now we can consider the second part of the algorithm. We bring one pointer to the start of the list.
Now when this pointer takes m steps, it reaches the start of the loop.
How much distance would the second pointer have covered by this time? It would be m+k.
Why? Since it was already at an offset k after the first step of the algorithm and then it travels m more steps.</p><p>Now we know that (m+k) is a multiple of l. That means the second pointer has reached the start of the loop and so has the first pointer. This implies that both the pointer will meet at the beginning of the loop after the second step of the algorithm. Hence the algorithm works.</p><p><a href="https://www.youtube.com/watch?v=apIw0Opq5nk">Credit</a></p></div><footer class=post-footer><ul class=post-tags></ul></footer></article></main><footer class=footer><span>&copy; 2024 <a href=https://tanayjha.github.io/></a></span><span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>